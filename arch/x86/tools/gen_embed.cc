/**
 * Generate the contents of the "embedded" data.
 * Copyright (C) 2025-present  dbstream
 *
 * The final kernel binary is appended with the embed data generated by this
 * file.  This is used for kernel access to the kernel symbols and for stack
 * unwind information.
 */
 #include <elf.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#include <vector>

static void *kernel;

static std::vector<uint8_t> output;

static inline uint64_t
add_zeroes (uint64_t n)
{
	uint64_t offset = output.size ();
	while (n--) output.push_back (0);
	return offset;
}

static inline uint64_t
set_u64 (uint64_t offset, uint64_t value)
{
	output[offset + 0] = value >> (8 * 0);
	output[offset + 1] = value >> (8 * 1);
	output[offset + 2] = value >> (8 * 2);
	output[offset + 3] = value >> (8 * 3);
	output[offset + 4] = value >> (8 * 4);
	output[offset + 5] = value >> (8 * 5);
	output[offset + 6] = value >> (8 * 6);
	output[offset + 7] = value >> (8 * 7);
	return offset;
}

static inline uint64_t
add_output (uint64_t x)
{
	return set_u64 (add_zeroes (8), x);
}

int
main (int argc, char **argv)
{
	if (argc != 2) {
		fprintf (stderr, "usage:  gen_embed path/to/davix.elf > output\n");
		return 1;
	}

	int fd = open (argv[1], O_RDONLY);
	if (fd == -1) {
		perror ("failed to open kernel ELF binary");
		return 1;
	}

	/**
	 * Perform some basic validations to make sure that a kernel ELF binary
	 * is (probably) provided to the tool.
	 */

	struct stat stat;
	if (fstat (fd, &stat) == -1) {
		perror ("failed to stat kernel ELF binary");
		return 1;
	}

	if (stat.st_size < sizeof (Elf64_Ehdr)) {
		fprintf (stderr, "kernel binary is too small\n");
		return 1;
	}

	kernel = mmap (NULL, stat.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
	if (kernel == MAP_FAILED) {
		perror ("failed to mmap kernel ELF binary");
		return 1;
	}

	if (memcmp (kernel, "\x7F\x45\x4c\x46", 4) != 0) {
		fprintf (stderr, "kernel binary does not appear to be an ELF binary\n");
		return 1;
	}

	add_zeroes (8);
	add_output (42);
	set_u64 (0, output.size ());
	if (write (STDOUT_FILENO, output.data (), output.size()) != output.size ()) {
		fprintf (stderr, "failed to write output\n");
		return 1;
	}

	return 0;
}

