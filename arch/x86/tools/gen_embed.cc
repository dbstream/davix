/**
 * Generate the contents of the "embedded" data.
 * Copyright (C) 2025-present  dbstream
 *
 * The final kernel binary is appended with the embed data generated by this
 * file.  This is used for kernel access to the kernel symbols and for stack
 * unwind information.
 *
 * Format of the embedded information:
 *
 *	+---------offset+--size (bytes)+----------------------------------value+
 *	|             0 |            8 | Total size of the embedded data.      |
 *	|             8 |            8 | Offset of symbol table.           (S) |
 *      |            16 |            8 | Number of entries in symbol table.    |
 *      |            24 |            8 | Offset of unwind table.           (U) |
 *      |            32 |            8 | Number of entries in unwind table.    |
 *      |      ...      |     ...      |                 ...                   |
 *      |  S + 24*i + 0 |            8 | Value of symbol i.                    |
 *      |  S + 24*i + 8 |            8 | Size of symbol i.                     |
 *      | S + 24*i + 16 |            8 | Offset of symbol name.                |
 *      |      ...      |     ...      |                 ...                   |
 *      |  U + 24*i + 0 |            8 | Start of unwind PC range.             |
 *      |  U + 24*i + 8 |            1 | Unwind flags (see below).             |
 *      |  U + 24*i + 9 |            5 | Reserved.                             |
 *      | U + 24*i + 14 |            2 | Offset from %rsp of next frame.       |
 *      |      ...      |     ...      |                 ...                   |
 *      +---------------+--------------+---------------------------------------+
 *
 * Unwind flags:
 *	Bit 7	If this bit is set, the region between this entry and the next
 *		entry is unwindable.  Otherwise, it represents a region that
 *		we don't have unwind information for.
 *	Bit 6	If this bit is set, the region covered by this entry represents
 *		a signal frame ('.cfi_signal_frame').  In that case, the "offset
 *		from %rsp of next frame" points to an architecture-defined iretq
 *		frame.
 */
#include <dwarf.h>
#include <endian.h>
#include <fcntl.h>
#include <gelf.h>
#include <libelf.h>
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#include <algorithm>
#include <string>
#include <vector>

static Elf *kernel;

static std::vector<uint8_t> output;

static inline uint64_t
add_cstring (const char *s)
{
	uint64_t offset = output.size ();
	do {
		output.push_back (*s);
	} while (*(s++));
	return offset;
}

static inline uint64_t
align_to_8 (void)
{
	for (size_t i = output.size(); i & 7; i++)
		output.push_back (0);
	return output.size ();
}

static inline uint64_t
add_zeroes (uint64_t n)
{
	uint64_t offset = output.size ();
	while (n--) output.push_back (0);
	return offset;
}

static inline uint64_t
set_u16 (uint64_t offset, uint16_t value)
{
	output[offset + 0] = value >> (8 * 0);
	output[offset + 1] = value >> (8 * 1);
	return offset;
}

static inline uint64_t
set_u32 (uint64_t offset, uint32_t value)
{
	output[offset + 0] = value >> (8 * 0);
	output[offset + 1] = value >> (8 * 1);
	output[offset + 2] = value >> (8 * 2);
	output[offset + 3] = value >> (8 * 3);
	return offset;
}

static inline uint64_t
set_u64 (uint64_t offset, uint64_t value)
{
	output[offset + 0] = value >> (8 * 0);
	output[offset + 1] = value >> (8 * 1);
	output[offset + 2] = value >> (8 * 2);
	output[offset + 3] = value >> (8 * 3);
	output[offset + 4] = value >> (8 * 4);
	output[offset + 5] = value >> (8 * 5);
	output[offset + 6] = value >> (8 * 6);
	output[offset + 7] = value >> (8 * 7);
	return offset;
}

static inline uint64_t
add_output (uint64_t x)
{
	return set_u64 (add_zeroes (8), x);
}

struct Symbol {
	uint64_t value;
	uint64_t size;
	uint64_t name_offset;
	std::string name;
};

static std::vector<Symbol> symbols;

struct UnwindRegion {
	uint64_t addr;
	bool unwindable;
	bool signal;
	uint16_t offset;
};

static std::vector<UnwindRegion> unwind_regions;

static inline int
read_uleb128 (const uint8_t *p, uint64_t *out)
{
	uint64_t value = 0;
	for (int i = 0; i < 10; i++) {
		uint8_t x = *(p++);
		value |= (x & 0x7f) << (7 * i);
		if (!(x & 0x80)) {
			*out = value;
			return i + 1;
		}
	}

	fprintf (stderr, "uleb128-encoded number is too large\n");
	exit (1);
}

static inline int
read_signextend_leb128 (const uint8_t *p, uint64_t *out)
{
	uint64_t value = 0;
	for (int i = 0; i < 10; i++) {
		uint8_t x = *(p++);
		value |= (x & 0x7f) << (7 * i);
		if (!(x & 0x80)) {
			if (i < 9 && (value & (1ULL << (7 * i + 6))))
				value |= 0xffffffffffffff80ULL << (7 * i);
			*out = value;
			return i + 1;
		}
	}

	fprintf (stderr, "sleb128-encoded number is too large\n");
	exit (1);
}

/**
 * The '(int64_t) value' conversion depends on twos-complement to work.  This is
 * not an issue since the casting behavior we expect is guaranteed by C++20.
 * Assert it anyways.
 */
static_assert ((int64_t)(uint64_t) 0xffffffffffffffffULL == (int64_t) -1, "not twos-complement");
static_assert ((int64_t)(uint64_t) 0xfffffffffffffffeULL == (int64_t) -2, "not twos-complement");

static inline int
read_sleb128 (const uint8_t *p, int64_t *out)
{
	uint64_t value;
	int i = read_signextend_leb128 (p, &value);
	*out = (int64_t) value;
	return i;
}

static inline int
read_u16 (const uint8_t *p, uint16_t *out)
{
	*out = p[0] | ((uint16_t) p[1] << 8);
	return 2;
}

static inline int
read_u32 (const uint8_t *p, uint32_t *out)
{
	*out = p[0] | ((uint32_t) p[1] << 8) | ((uint32_t) p[2] << 16)
		| ((uint32_t) p[3] << 24);
	return 4;
}

static inline int
read_u64 (const uint8_t *p, uint64_t *out)
{
	*out = p[0] | ((uint64_t) p[1] << 8) | ((uint64_t) p[2] << 16)
		| ((uint64_t) p[3] << 24) | ((uint64_t) p[4] << 32) | ((uint64_t) p[5] << 40)
		| ((uint64_t) p[6] << 48) | ((uint64_t) p[7] << 56);
	return 8;
}

static inline int
read_u32or64 (const uint8_t *p, bool is_64bit, uint64_t *out)
{
	if (is_64bit)
		return read_u64 (p, out);

	uint32_t u32;
	int i = read_u32 (p, &u32);
	*out = u32;
	return i;
}

#define REG_RAX		0
#define REG_RDX		1
#define REG_RCX		2
#define REG_RBX		3
#define REG_RSI		4
#define REG_RDI		5
#define REG_RBP		6
#define REG_RSP		7
#define REG_R8		8
#define REG_R9		9
#define REG_R10		10
#define REG_R11		11
#define REG_R12		12
#define REG_R13		13
#define REG_R14		14
#define REG_R15		15
#define REG_IP		16

struct CIE_Info {
	const uint8_t *insns_start;
	const uint8_t *end;
	const char *augmentation;
	uint64_t code_alignment_factor;
	uint64_t data_alignment_factor; /** 'signed' but we pretend it isn't  */
	uint64_t ret_column;
	uint64_t augmentation_length;
	const uint8_t *augmentation_data;
	uint8_t fde_encoding;
	bool is_signal_frame;
};

/**
 * From the LSB (https://refspecs.linuxfoundation.org):
 *
 *	Note: The format of the .eh_frame section is similar in format and
 *	purpose to the .debug_frame section which is specified in DWARF
 *	Debugging Information Format, Revision 3.0.0 (Draft). Readers are
 *	advised that there are some subtle difference, and care should be
 *	taken when comparing the two sections.
 */

static CIE_Info
parse_cie (const uint8_t *p)
{
	CIE_Info info;

	uint64_t length;
	uint32_t u32, CIE_id;

	bool is_64bit = false;

	p += read_u32 (p, &u32);
	if (u32 == 0xffffffffU) {
		is_64bit = true;
		p += read_u64 (p, &length);
	} else if (u32 >= 0xfffffff0U) {
		fprintf (stderr, "unknown initial length\n");
		exit (1);
	} else
		length = u32;
	info.end = p + length;

	p += read_u32 (p, &CIE_id);
	if (CIE_id != 0) {
		fprintf (stderr, "CIE_id != 0\n");
		exit (1);
	}

	p++;	/** skip 'version (ubyte)'  */
	info.augmentation = (const char *) p;
	p += strlen (info.augmentation) + 1;

	if (*info.augmentation && *info.augmentation != 'z') {
		fprintf (stderr, "unsupported augmentation string: \"%s\"\n",
				info.augmentation);
		exit (1);
	}

	p += read_uleb128 (p, &info.code_alignment_factor);
	p += read_signextend_leb128 (p, &info.data_alignment_factor);
	p += read_uleb128 (p, &info.ret_column);
	if (strchr (info.augmentation, 'z')) {
		p += read_uleb128 (p, &info.augmentation_length);
		info.augmentation_data = p;
		p += info.augmentation_length;
	} else {
		info.augmentation_length = 0;
		info.augmentation_data = nullptr;
	}

	info.insns_start = p;

	const char *s = info.augmentation;

	p = info.augmentation_data;
	info.fde_encoding = DW_EH_PE_sdata4 | DW_EH_PE_pcrel;
	info.is_signal_frame = false;
	for (; *s; s++) {
		if (*s == 'z')
			continue;
		if (*s == 'S') {
			info.is_signal_frame = true;
			continue;
		}
		if (*s == 'R') {
			info.fde_encoding = *(p++);
			continue;
		}
		fprintf (stderr, "unsupported augmentation string: \"%s\"\n",
				info.augmentation);
		exit (1);
	}

	return info;
}

struct RegisterState {
	int rule;
	uint64_t a, b;
};

struct Row {
	RegisterState registers[17];
	RegisterState cfa;
	uint64_t pos;
	bool is_signal_frame;
};

static uint64_t eh_frame_addr;
static const uint8_t *eh_frame_base;

static int
read_enc (const uint8_t *p, uint8_t enc, uint64_t *out)
{
	if (enc != (DW_EH_PE_sdata4 | DW_EH_PE_pcrel)) {
		fprintf (stderr, "unsupported encoding\n");
		exit (1);
	}

	uint64_t base = eh_frame_addr + (p - eh_frame_base);

	uint32_t offset;
	int i = read_u32 (p, &offset);

	if (offset & 0x80000000U) {
		offset = ~offset;
		offset++;
		*out = base - offset;
	} else
		*out = base + offset;

	return i;
}

static int
read_enc_abs (const uint8_t *p, uint8_t enc, uint64_t *out)
{
	if (enc != (DW_EH_PE_sdata4 | DW_EH_PE_pcrel)) {
		fprintf (stderr, "unsupported encoding\n");
		exit (1);
	}

	uint32_t u32;
	int i = read_u32 (p, &u32);
	*out = u32;
	return i;
}

static void
emit_row (const Row &row)
{
	UnwindRegion r;
	r.signal = false;
	r.offset = 0xffff;
	r.addr = row.pos;

	uint16_t cfa = 0xffff;
	switch (row.cfa.rule) {
	case DW_CFA_val_offset:
		if (row.cfa.a == REG_RSP)
			cfa = row.cfa.b;
		else
			fprintf (stderr, "warning: pc=%llx  CFA register is not %%rsp\n",
					(unsigned long long) row.pos);
		break;
	default:
		fprintf (stderr, "warning: pc=%llx  CFA rule is not DW_CFA_val_offset\n",
				(unsigned long long) row.pos);
		break;
	}

	if (cfa == 0xffff)
		goto not_unwindable;

	switch (row.registers[REG_IP].rule) {
	case DW_CFA_offset:
		r.offset = cfa + row.registers[REG_IP].a + 8;
		break;
	case DW_CFA_undefined:
		/** intentionally undefined  */
		break;
	default:
		fprintf (stderr, "warning: pc=%llx  CFA rule is not DW_CFA_offset nor DW_CFA_undefined\n",
				(unsigned long long) row.pos);
		break;
	}

	if (row.is_signal_frame) {
		if (row.registers[REG_RSP].rule != DW_CFA_offset) {
			fprintf (stderr, "warning: pc=%llx  CFA rule is not DW_CFA_offset but the frame is a signal frame\n",
					(unsigned long long) row.pos);
			goto not_unwindable;
		}
	}

	if (r.offset == 0xffff) {
not_unwindable:
		r.unwindable = false;
		r.offset = 0;
	} else
		r.unwindable = true;
	unwind_regions.push_back (r);
}

static void
cfa_interpret (Row &row, const CIE_Info &info, const uint8_t *p, const uint8_t *end)
{
	Row row_orig = row;
	std::vector<Row> stack;
	while (p < end) {
		uint64_t op1, op2;
		uint16_t u16;
		uint32_t u32;
		uint8_t opcode = *(p++);
		if ((opcode & 0xc0) == DW_CFA_advance_loc) {
			op1 = opcode & 0x3f;
			goto advance_loc_common;
		} else if ((opcode & 0xc0) == DW_CFA_offset) {
			op1 = opcode & 0x3f;
			p += read_uleb128 (p, &op2);
			goto offset_common;
		} else if ((opcode & 0xc0) == DW_CFA_restore) {
			op1 = opcode & 0x3f;
			goto restore_common;
		} else switch (opcode) {
		case DW_CFA_nop:
			break;
		case DW_CFA_set_loc:
			p += read_enc (p, info.fde_encoding, &op1);
			emit_row (row);
			row.pos = op1;
			break;
		case DW_CFA_advance_loc1:
			op1 = *(p++);
			goto advance_loc_common;
		case DW_CFA_advance_loc2:
			p += read_u16 (p, &u16);
			op1 = u16;
			goto advance_loc_common;
		case DW_CFA_advance_loc4:
			p += read_u32 (p, &u32);
			op1 = u32;
advance_loc_common:
			emit_row (row);
			row.pos += op1 * info.code_alignment_factor;
			break;
		case DW_CFA_offset_extended:
			p += read_uleb128 (p, &op1);
			p += read_uleb128 (p, &op2);
offset_common:
			if (op1 < 17) {
				row.registers[op1].rule = DW_CFA_offset;
				row.registers[op1].a = op2 * info.data_alignment_factor;
			}
			break;
		case DW_CFA_restore_extended:
			p += read_uleb128 (p, &op1);
restore_common:
			if (op1 < 17)
				row.registers[op1] = row_orig.registers[op1];
			break;
		case DW_CFA_undefined:
			p += read_uleb128 (p, &op1);
			if (op1 < 17)
				row.registers[op1].rule = DW_CFA_undefined;
			break;
		case DW_CFA_same_value:
			p += read_uleb128 (p, &op1);
			if (op1 < 17)
				row.registers[op1].rule = DW_CFA_same_value;
			break;
		case DW_CFA_register:
			p += read_uleb128 (p, &op1);
			p += read_uleb128 (p, &op2);
			if (op1 < 17) {
				row.registers[op1].rule = DW_CFA_register;
				row.registers[op1].a = op2;
			}
			break;
		case DW_CFA_remember_state:
			stack.push_back (row);
			break;
		case DW_CFA_restore_state:
			op1 = row.pos;
			row = stack.back ();
			stack.pop_back ();
			row.pos = op1;
			break;
		case DW_CFA_def_cfa:
			p += read_uleb128 (p, &op1);
			p += read_uleb128 (p, &op2);
def_cfa_common:
			row.cfa.rule = DW_CFA_val_offset;
			row.cfa.a = op1;
			row.cfa.b = op2;
			break;
		case DW_CFA_def_cfa_register:
			p += read_uleb128 (p, &op1);
			row.cfa.a = op1;
			break;
		case DW_CFA_def_cfa_offset:
			p += read_uleb128 (p, &op1);
			row.cfa.b = op1;
			break;
		case DW_CFA_offset_extended_sf:
			p += read_uleb128 (p, &op1);
			p += read_signextend_leb128 (p, &op2);
			goto offset_common;
		case DW_CFA_def_cfa_sf:
			p += read_uleb128 (p, &op1);
			p += read_signextend_leb128 (p, &op2);
			op2 *= info.data_alignment_factor;
			goto def_cfa_common;
		case DW_CFA_def_cfa_offset_sf:
			p += read_signextend_leb128 (p, &op1);
			row.cfa.b = op1 * info.data_alignment_factor;
			break;
		case DW_CFA_val_offset:
			p += read_uleb128 (p, &op1);
			p += read_uleb128 (p, &op2);
val_offset_common:
			if (op1 < 17) {
				row.registers[op1].rule = DW_CFA_val_offset;
				row.registers[op1].a = op2 * info.data_alignment_factor;
			}
			break;
		case DW_CFA_val_offset_sf:
			p += read_uleb128 (p, &op1);
			p += read_signextend_leb128 (p, &op2);
			goto val_offset_common;
		default:
			fprintf (stderr, "unsupported CFI opcode: 0x%02x\n", opcode);
			exit (1);
		}
	}
}

static void
parse_eh_frame (Elf_Data data)
{
	const uint8_t *p, *P = (const uint8_t *) data.d_buf;
	const uint8_t *const end = P + data.d_size;

	eh_frame_base = P;

	for (; P < end; ) {
		uint64_t length;
		uint32_t u32, CIE_pointer;

		bool is_64bit = false;
		
		p = P;
		p += read_u32 (p, &u32);
		if (u32 == 0xffffffffU) {
			is_64bit = true;
			p += read_u64 (p, &length);
		} else if (u32 >= 0xfffffff0U) {
			fprintf (stderr, "unknown initial length\n");
			exit (1);
		} else
			length = u32;

		if (!length)
			break;

		P = p + length;

		p += read_u32 (p, &CIE_pointer);
		if (!CIE_pointer) {
			/**
			 * This is a CIE, parsed later.  Skip it for now.
			 */
			continue;
		}

		CIE_Info info = parse_cie (p - 4 - CIE_pointer);

		uint64_t start_pc, end_pc, pc_length;
		p += read_enc (p, info.fde_encoding, &start_pc);
		p += read_enc_abs (p, info.fde_encoding, &pc_length);

		end_pc = start_pc + pc_length;
		if (*info.augmentation == 'z') {
			uint64_t augmentation_length;
			p += read_uleb128 (p, &augmentation_length);
			p += augmentation_length;
		}

		if (info.ret_column != REG_IP) {
			fprintf (stderr, "unsupported ret_column\n");
			exit (1);
		}

		Row row;
		row.is_signal_frame = info.is_signal_frame;
		row.pos = start_pc;
		row.cfa.rule = DW_CFA_undefined;
		for (int i = 0; i < 17; i++)
			row.registers[i].rule = DW_CFA_undefined;
		cfa_interpret (row, info, info.insns_start, info.end);
		cfa_interpret (row, info, p, P);

		UnwindRegion r;
		r.unwindable = false;
		r.addr = end_pc;
		r.offset = 0;
		unwind_regions.push_back (r);
	}
}

int
main (int argc, char **argv)
{
	if (argc != 2) {
		fprintf (stderr, "usage:  gen_embed path/to/davix.elf > output\n");
		return 1;
	}

	if (elf_version (EV_CURRENT) != EV_CURRENT) {
		fprintf (stderr, "failed to initialize libelf: %s\n", elf_errmsg (-1));
		return 1;
	}

	int fd = open (argv[1], O_RDONLY);
	if (fd == -1) {
		perror ("failed to open kernel ELF binary");
		return 1;
	}

	kernel = elf_begin (fd, ELF_C_READ, NULL);
	if (!kernel) {
		fprintf (stderr, "elf_begin() failed: %s\n", elf_errmsg(-1));
		return 1;
	}

	if (elf_kind (kernel) != ELF_K_ELF) {
		fprintf (stderr, "elf_kind() is not ELF_K_ELF\n");
		return 1;
	}

	/**
	 * embed[0...7] = sizeof embed
	 * embed[8...15] = symbol offset
	 * embed[16...23] = symbol count
	 * embed[24...31] = unwind offset
	 * embed[32...39] = unwind count
	 */
	add_zeroes (40);

	Elf_Scn *scn = NULL;
	GElf_Shdr shdr;
	while ((scn = elf_nextscn (kernel, scn))) {
		if (gelf_getshdr (scn, &shdr) != &shdr) {
			fprintf (stderr, "gelf_getshdr() failed: %s\n", elf_errmsg (-1));
			return 1;
		}

		if (shdr.sh_type == SHT_SYMTAB)
			break;
	}

	if (!scn) {
		fprintf (stderr, "couldn't find SHT_SYMTAB in kernel ELF binary\n");
		return 1;
	}

	Elf_Data *data = elf_getdata (scn, NULL);
	if (!data) {
		fprintf (stderr, "elf_getdata() failed: %s\n", elf_errmsg (-1));
		return 1;
	}

	const auto sym_count = shdr.sh_size / shdr.sh_entsize;
	for (auto i = 0; i < sym_count; i++) {
		GElf_Sym sym;
		if (gelf_getsym (data, i, &sym) != &sym) {
			fprintf (stderr, "gelf_getsym() failed: %s\n", elf_errmsg (-1));
			return 1;
		}

		unsigned char type = ELF64_ST_TYPE (sym.st_info);
		if (type != STT_FUNC)
			continue;

		const char *p = elf_strptr (kernel, shdr.sh_link, sym.st_name);
		if (!p) {
			fprintf (stderr, "elf_strptr() failed: %s\n", elf_errmsg (-1));
			return 1;
		}

		Symbol s = { sym.st_value, sym.st_size, 0, p };
		symbols.push_back (std::move (s));
	}

	std::sort (std::begin (symbols), std::end (symbols), [](const Symbol &lhs, const Symbol &rhs){
		return lhs.value < rhs.value;
	});

	for (Symbol &sym : symbols)
		sym.name_offset = add_cstring (sym.name.c_str ());

	set_u64 (8, align_to_8 ());
	set_u64 (16, symbols.size ());
	for (Symbol &sym : symbols) {
		add_output (sym.value);
		add_output (sym.size);
		add_output (sym.name_offset);
	}

	size_t shstrndx;
	if (elf_getshdrstrndx (kernel, &shstrndx) != 0) {
		fprintf (stderr, "elf_getshdrstrndx() failed: %s\n", elf_errmsg (-1));
		return 1;
	}

	scn = NULL;
	while ((scn = elf_nextscn (kernel, scn))) {
		if (gelf_getshdr (scn, &shdr) != &shdr) {
			fprintf (stderr, "gelf_getshdr() failed: %s\n", elf_errmsg (-1));
			return 1;
		}

		if (shdr.sh_type != SHT_PROGBITS)
			continue;

		const char *p = elf_strptr (kernel, shstrndx, shdr.sh_name);
		if (!p) {
			fprintf (stderr, "elf_strptr() failed: %s\n", elf_errmsg (-1));
			return 1;
		}

		if (!strcmp (p, ".eh_frame"))
			break;
	}

	if(!scn) {
		fprintf (stderr, "couldn't find .eh_frame in kernel ELF binary\n");
		return 1;
	}

	if (gelf_getshdr (scn, &shdr) != &shdr) {
		fprintf (stderr, "gelf_getshdr() failed: %s\n", elf_errmsg (-1));
		return 1;
	}

	data = elf_getdata (scn, NULL);
	if (!data) {
		fprintf (stderr, "elf_getdata() failed: %s\n", elf_errmsg (-1));
		return 1;
	}

	if (data->d_type != ELF_T_BYTE) {
		fprintf (stderr, "elf_getdata()->d_type is not ELF_T_BYTE\n");
		return 1;
	}

	eh_frame_addr = shdr.sh_addr;
	parse_eh_frame (*data);

	std::sort (std::begin (unwind_regions), std::end (unwind_regions),
		[](const UnwindRegion &lhs, const UnwindRegion &rhs) {
			if (lhs.addr < rhs.addr)
				return true;
			if (lhs.addr > rhs.addr)
				return false;
			if (lhs.unwindable && !rhs.unwindable)
				return true;
			return false;
		}
	);

	set_u64 (24, align_to_8 ());
	uint64_t num_unwind_regions = 0;

	uint64_t prevpc = 0;
	bool prevunwindable = false;
	for (const UnwindRegion &r : unwind_regions) {
		if (!r.unwindable && !prevunwindable) {
//			fprintf (stderr, "  skipping row %llx\n",
//					(unsigned long long) r.addr);
			continue;
		} if (r.addr == prevpc)
			continue;
		prevpc = r.addr;
		prevunwindable = r.unwindable;
		
		uint64_t offset = add_zeroes (16);
		set_u64 (offset, r.addr);
		set_u32 (offset + 8, (r.unwindable << 7) | (r.signal << 6));
		set_u16 (offset + 12, 0);
		set_u16 (offset + 14, r.offset);
		num_unwind_regions++;
	}
	fprintf (stderr, "  prevpc=%llx  prevunwindable=%d\n",
			(unsigned long long) prevpc, prevunwindable);
	fprintf (stderr, "  number of emitted CFI rows: %llu\n",
			(unsigned long long) num_unwind_regions);

	set_u64 (32, num_unwind_regions);
	set_u64 (0, output.size ());
	if (write (STDOUT_FILENO, output.data (), output.size()) != output.size ()) {
		fprintf (stderr, "failed to write output\n");
		return 1;
	}

	return 0;
}

